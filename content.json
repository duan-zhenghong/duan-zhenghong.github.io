{"meta":{"title":"dzh Blog","subtitle":"","description":"","author":"dzh","url":"https://duan-zhenghong.github.io/dzh.github.io","root":"/dzh.github.io/"},"pages":[],"posts":[{"title":"","slug":"md&typora","date":"2021-07-11T17:46:46.958Z","updated":"2021-07-11T17:46:46.958Z","comments":true,"path":"2021/07/12/md&typora/","link":"","permalink":"https://duan-zhenghong.github.io/dzh.github.io/2021/07/12/md&typora/","excerpt":"","text":"md文档中插入图片和上传 https://www.jianshu.com/p/47c61c924669","categories":[],"tags":[]},{"title":"","slug":"linux","date":"2021-07-11T17:46:46.842Z","updated":"2021-07-11T17:46:46.846Z","comments":true,"path":"2021/07/12/linux/","link":"","permalink":"https://duan-zhenghong.github.io/dzh.github.io/2021/07/12/linux/","excerpt":"","text":"固定ip配置修改配置文件文件所在目录：/etc/netplan/01-network-manager-all.yaml 在Ubuntu17后采用该文件配置，是一种类似与xml的配置文件 配置文件内容静态IP配置1234567891011# Let NetworkManager manage all devices on this systemnetwork: version: 2 renderer: NetworkManager ethernets: eth0: dhcp4: false addresses: [192.168.1.4/24] gateway4: 192.168.1.1 nameservers: addresses: [8.8.8.8, 114.114.114.114] dhcp4: 其中的4表示针对ipv4，其他类似 addresses：可以有多个，逗号隔开即可 eth0：网卡名称，通过ip addr 命令可以查到 ethernets：网卡信息，其中可以并列配置多张网卡 注意各个字段和内容冒号后要空格 动态IP配置1234567# Let NetworkManager manage all devices on this systemnetwork: version: 2 renderer: NetworkManager ethernets: eth0: dhcp4: true 配置多个网卡如果虚拟机创建了又一个网卡，但是没有对应的ip配置，可通过如下方法： 12vim /etc/netplan/02-network-manager-all.yamlsudo netplan apply 创建一个新的网卡配置文件02-network-manager-all.yaml，并将配如下的信息写入，刷新网卡，既可以看到配置的固定ip network: version: 2 renderer: NetworkManager ethernets: eth0: dhcp4: false addresses: [192.168.1.4/24] gateway4: 192.168.1.1 nameservers: addresses: [8.8.8.8, 114.114.114.114] 配置生效1sudo netplan apply 即时生效，无序重启，生效后可以通过ip addr命令查看到网卡的ip 附录1sudo netplan --debug apply 增加–debug可以看到执行过程，遇到问题方便定位 linux 命令学习笔记如何学习使用命令123456789101112131415161718192021222324duanzhenghong@duanzhenghong-pc:~$ uname --help用法：uname [选项]...输出一组系统信息。如果不跟随选项，则视为只附加 -s 选项。 -a, --all 以如下次序输出所有信息。其中若 -p 和 -i 的探测结果不可知则被省略： -s, --kernel-name 输出内核名称 -n, --nodename 输出网络节点上的主机名 -r, --kernel-release 输出内核发行号 -v, --kernel-version 输出内核版本 -m, --machine 输出主机的硬件架构名称 -p, --processor 输出处理器类型（不可移植） -i, --hardware-platform 输出硬件平台或（不可移植） -o, --operating-system 输出操作系统名称 --help 显示此帮助信息并退出 --version 显示版本信息并退出GNU coreutils 在线帮助：&lt;https://www.gnu.org/software/coreutils/&gt;请向 &lt;http://translationproject.org/team/zh_CN.html&gt; 报告 uname 的翻译错误完整文档请见：&lt;https://www.gnu.org/software/coreutils/uname&gt;或者在本地使用：info &#x27;(coreutils) uname invocation&#x27;duanzhenghong@duanzhenghong-pc:~$ info unameduanzhenghong@duanzhenghong-pc:~$ man uname 以 uname 为例子,如上展示了三种查看帮助和手册的方法, man 命令实际是manual的缩写 命令按功能分类查看系统的一些基本信息版本123456789101112131415161718192021duanzhenghong@duanzhenghong-pc:~$ cat /etc/issueUbuntu 20.04.2 LTS \\n \\lduanzhenghong@duanzhenghong-pc:~$ cat /etc/os-releaseNAME=&quot;Ubuntu&quot;VERSION=&quot;20.04.2 LTS (Focal Fossa)&quot;ID=ubuntuID_LIKE=debianPRETTY_NAME=&quot;Ubuntu 20.04.2 LTS&quot;VERSION_ID=&quot;20.04&quot;HOME_URL=&quot;https://www.ubuntu.com/&quot;SUPPORT_URL=&quot;https://help.ubuntu.com/&quot;BUG_REPORT_URL=&quot;https://bugs.launchpad.net/ubuntu/&quot;PRIVACY_POLICY_URL=&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;VERSION_CODENAME=focalUBUNTU_CODENAME=focalduanzhenghong@duanzhenghong-pc:~$ lsb_release -aNo LSB modules are available.Distributor ID: UbuntuDescription: Ubuntu 20.04.2 LTSRelease: 20.04Codename: focal LSB（linux标准库linux standard base） 1234567duanzhenghong@duanzhenghong-pc:~$ unameLinuxduanzhenghong@duanzhenghong-pc:~$ uname -aLinux duanzhenghong-pc 5.8.0-50-generic #56~20.04.1-Ubuntu SMP Mon Apr 12 21:46:35 UTC 2021 x86_64 x86_64 x86 _64 GNU/Linuxduanzhenghong@duanzhenghong-pc:~$ uname -v#56~20.04.1-Ubuntu SMP Mon Apr 12 21:46:35 UTC 2021 线程ps -ef 常配合管道命令 | 和查找命令 grep 同时执行来查看特定进程。 参数含义: -e 显示所有进程。-f 全格式。-h 不显示标题。-l 长格式。-w 宽输出。a 显示终端上的所有进程，包括其他用户的进程。r 只显示正在运行的进程。x 显示没有控制终端的进程。 top 实时显示进程信息 htop htop是top的增强版,显示色彩,在命令行可以交互控制进程 建立软连接 1234567891011121314151617root@dzh-pc:/usr/bin# ll | grep pythonlrwxrwxrwx 1 root root 23 5月 27 21:30 pdb3.8 -&gt; ../lib/python3.8/pdb.py*lrwxrwxrwx 1 root root 31 3月 9 23:25 py3versions -&gt; ../share/python3/py3versions.py*lrwxrwxrwx 1 root root 9 3月 9 23:25 python3 -&gt; python3.8*-rwxr-xr-x 1 root root 5482296 5月 27 21:30 python3.8*root@dzh-pc:/usr/bin# ln -s python3.8 pythonroot@dzh-pc:/usr/bin# ll | grep pythonlrwxrwxrwx 1 root root 23 5月 27 21:30 pdb3.8 -&gt; ../lib/python3.8/pdb.py*lrwxrwxrwx 1 root root 31 3月 9 23:25 py3versions -&gt; ../share/python3/py3versions.py*lrwxrwxrwx 1 root root 9 6月 3 23:12 python -&gt; python3.8*lrwxrwxrwx 1 root root 9 3月 9 23:25 python3 -&gt; python3.8*-rwxr-xr-x 1 root root 5482296 5月 27 21:30 python3.8*root@dzh-pc:/usr/bin# pythonPython 3.8.5 (default, May 27 2021, 13:30:53)[GCC 9.3.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 通过建立软连接python -&gt; python3.8，可以直接使用python来调用python3.8 计算机名1234duanzhenghong@duanzhenghong-pc:~$ cat /etc/hostnameduanzhenghong-pcduanzhenghong@duanzhenghong-pc:~$ hostnameduanzhenghong-pc hostname在linux和dos都可以使用 1vim /etc/hostname 修改hostname文件中的名字并重启就可以改变计算机的名字 配置固定ip的思路(hyper-v虚拟机) 虚拟机配置dhcp,使用默认的虚拟交换机(自动配饰nat内网穿透功能),同时在windows主机下,将外网共享给默认的虚拟交换机,配置后可以访问外网. 创建一个内部交换机(假设名为fixIP),指定为内部网络,其他默认,然后再对应的虚拟机设置上增加(注意是增加,默认的交换机仍在)一个网络适配器,指定使用fixIP虚拟交换机.然后启动虚拟机,虚拟机中会增加一个网卡,修改该网卡对应的配置文件,配置为static,配置一个固定ip,同时在主机环境中将fixIP指定一个ip(与虚拟机设置的固定ip同网段) 虚拟机的代理功能配置 全局变量增加 123export http_proxy=http://username:password@proxyhk.huawei.com:8080export https_proxy=http://username:password@proxyhk.huawei.com:8080 注意密码中包含的特殊字符需要转换成url编码格式 git代理设置 https://www.jianshu.com/p/290152303598 快捷键 快捷键 描述 ctrl + r 可以快速匹配历史命令,在历史命令中查找 ctrl + u 清除当前命令行的内容(光标之前的) ctrl + l 清屏 ctrl + t 命令行最后两字符交换位置 命令rm反选删除文件rm -rf !(file1 | file2) -r 表示遇到文件夹递归删除, -f表示强制删除, 命令表示表示删除当前目录下除了file1 和file2的所有文件","categories":[],"tags":[]},{"title":"","slug":"windows命令行","date":"2021-07-11T17:46:46.718Z","updated":"2021-07-11T17:46:46.718Z","comments":true,"path":"2021/07/12/windows命令行/","link":"","permalink":"https://duan-zhenghong.github.io/dzh.github.io/2021/07/12/windows%E5%91%BD%E4%BB%A4%E8%A1%8C/","excerpt":"","text":"windows命令行 1、在某个文件夹下快速进入该命令的命令行在文件夹地址栏输入cmd即可快速进入; 或者shift+右键选择进入powershell2、命令行切换盘符操作12D:\\repository\\md&gt;e:E:\\&gt;","categories":[],"tags":[]},{"title":"","slug":"SSH免密登陆设置","date":"2021-07-11T17:46:46.610Z","updated":"2021-07-11T17:46:46.610Z","comments":true,"path":"2021/07/12/SSH免密登陆设置/","link":"","permalink":"https://duan-zhenghong.github.io/dzh.github.io/2021/07/12/SSH%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"SSH免密登陆设置在Windows下查看**[c盘-&gt;用户-&gt;自己的用户名-&gt;.ssh]*下是否有“id_rsa、id_rsa.pub”*文件，如果没有需要从第一步开始手动生成,有的话直接跳到第二步。 第1步：创建SSH Key打开Git Bash，在控制台中输入以下命令: 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 密钥类型可以用 -t 选项指定。如果没有指定则默认生成用于SSH-2的RSA密钥。这里使用的是rsa。 同时在密钥中有一个注释字段，用-C来指定所指定的注释，可以方便用户标识这个密钥，指出密钥的用途或其他有用的信息。所以在这里输入自己的邮箱或者其他都行,当然，如果不想要这些可以直接输入： 1$ ssh-keygen 我一般就是这么做的。 输入完毕后按回车，程序会要求输入一个密码，输入完密码后按回车会要求再确认一次密码，如果不想要密码可以在要求输入密码的时候按两次回车，表示密码为空，并且确认密码为空，此时**[c盘&gt;用户&gt;自己的用户名&gt;.ssh]**目录下已经生成好了。 第2步：部署公钥版本管理仓库免密登陆不同的版本管理代码仓库都大同小异，这里以Github举例，登录Github。打开setting-&gt;SSH keys，点击右上角 New SSH key，把**[c盘-&gt;用户-&gt;自己的用户名-&gt;.ssh]*目录下生成好的公钥“id_rsa.pub”*文件以文本打开复制放进 key输入框中，再为当前的key起一个title来区分每个key。 其他Linux设备免密登陆实际上是将id_rsa.pub的内容放到authorized_keys文件内（没有的话就创建），注意要在对应的用户文件下放置，如下是在root用户的目录下 1$ cat /root/.ssh/id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys","categories":[],"tags":[]},{"title":"","slug":"python学习笔记","date":"2021-07-11T17:46:46.462Z","updated":"2021-07-11T17:46:46.462Z","comments":true,"path":"2021/07/12/python学习笔记/","link":"","permalink":"https://duan-zhenghong.github.io/dzh.github.io/2021/07/12/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"python学习笔记 [toc] 注释1、多行注释123456789方式1：&#x27;&#x27;&#x27;多行注释内容&#x27;&#x27;&#x27;方式2&quot;&quot;&quot;多行注释内容&quot;&quot;&quot; 2、特殊注释123Linux下起作用,放在文件行首的两个特殊注释#!/usr1/bin/python3 #指示python解释器的路径#--coding=utf-8-- #指定编码格式，python3之后默认utf-8可以不用写 变量1、变量类型 1234567891011121314graph LRA[python基本数据类型]--&gt; B[数字 num]A[python基本数据类型]--&gt; C[字符串 str]A[python基本数据类型]--&gt; D[&quot;字典 dict &#123;&#125;&quot;] A[python基本数据类型]--&gt; E[&quot;元组 tuple ()&quot;]A[python基本数据类型]--&gt; F[&quot;列表 list []&quot;]A[python基本数据类型]--&gt; N[&quot;集合 set &#123;&#125;&quot;]B[数字 num]--&gt; G[有符号整型 int]B[数字 num]--&gt; H[长整型 long #python3取消]B[数字 num]--&gt; I[浮点型 float]B[数字 num]--&gt; J[复数 conplex]B[数字 num]--&gt; K[布尔值 bool]K[布尔值 bool]--&gt; L[true]K[布尔值 bool]--&gt; M[false] 集合与字典不同 12jihe = &#123;1,2,3,4,5&#125;#与字典看上去类似，但是是不一样的。字典是 dict1 = &#123;key:value,key2:value2,&#125;需要key （1）集合自动去重 （2）集合打印内容无序， 因为无序，所以不支持切片和索引 集合方法：https://www.runoob.com/python3/python3-set.html#setmethod 2、查看变量类型 12type(变量名)isinstance(变量名, 类型名) #isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。 3、变量命名 （不能使用关键字） 123&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist[&#x27;False&#x27;, &#x27;None&#x27;, &#x27;True&#x27;, &#x27;and&#x27;, &#x27;as&#x27;, &#x27;assert&#x27;, &#x27;async&#x27;, &#x27;await&#x27;, &#x27;break&#x27;, &#x27;class&#x27;, &#x27;continue&#x27;, &#x27;def&#x27;, &#x27;del&#x27;, &#x27;elif&#x27;, &#x27;else&#x27;, &#x27;except&#x27;, &#x27;finally&#x27;, &#x27;for&#x27;, &#x27;from&#x27;, &#x27;global&#x27;, &#x27;if&#x27;, &#x27;import&#x27;, &#x27;in&#x27;, &#x27;is&#x27;, &#x27;lambda&#x27;, &#x27;nonlocal&#x27;, &#x27;not&#x27;, &#x27;or&#x27;, &#x27;pass&#x27;, &#x27;raise&#x27;, &#x27;return&#x27;, &#x27;try&#x27;, &#x27;while&#x27;, &#x27;with&#x27;, &#x27;yield&#x27;] 4、变量赋值 1a,b,c,d = 11,34,654,6 #多个变量可以同时赋值 可变数据类型与不可变数据类型 参考https://www.cnblogs.com/operationhome/p/9642460.html 数据类型 可变/不可变 整型 不可变 字符串 不可变 元组 不可变 列表 可变 集合 可变 字典 可变 运算符1、算数运算符 1234567891011#指数运算**# #相除取整# /相除&gt;&gt;&gt; a=2&gt;&gt;&gt; b=3&gt;&gt;&gt; a#b0&gt;&gt;&gt; a**b8&gt;&gt;&gt; a/b0.6666666666666666 2、比较运算符 12#下面6个运算符与c语言相同== != &lt; &gt; &lt;= &gt;= 3、逻辑运算符 12and or not# 优先级比较 () -&gt; not -&gt; and -&gt; or 4、赋值运算 12# **=# #= 输入输出1、格式化输出，占位符%, print自带换行 ，可以通过end参数指定行尾符号 12print(&#x27;我的名字是%s：来自【%s】&#x27; % (name, class))print(f&quot;&#123;name&#125;&quot;, end=&quot;!&quot;) #叹号结尾 2、常用格式化符号 format可以实现非常灵活的格式化输出 参考：[python基础_格式化输出（%用法和format用法）](https:#w ww.cnblogs.com/qinchao0317/p/10699717.html) 3、输入 input() 注意，输入的都是str类型 1name = input(&#x27;please input your name：&#x27;) 流程语句12graph LRA[流程语句]--&gt;B[顺序] &amp; C[选择] &amp; D[循环] 1、条件语句 elif相当于C语言中的else if 条件表达式：比较运算符、逻辑运算符、复合运算符 跳出if到下个分支处理的方法：1、下一行定格写 2、使用pass空语句，表示该代码块结束 循环语句1、两种循环 while主要用在不确定循环次数的场景while 条件表达式： ​ 循环体 for主要用于遍历for … in 可迭代的对象(字符串，列表等) ​ 循环体 2、for循环中用到的list与range 12345#range用法，python3中range返回的可迭代对象（类型是对象），而不是列表，range与list切片访问明确的边界都是左闭右开range(start, stop[, step])&gt;&gt;&gt; type(range(1,2,1))&lt;class &#x27;range&#x27;&gt; 3、for…else… 与 while…else.. 有时我们需要判断程序是正常退出循环（遍历完成），还是中途退出，据此来进行下面的不同操作。可能会加一个判断，比如下面的代码： 12345678910a = [1, 2, 3, 4]flag = Truefor i in range(len(a)): if a[i] == 2: flag = False breakif flag: print(&#x27;yes&#x27;)else: print(&#x27;no&#x27;) 用for … else 可以简化 1234567a = [1, 2, 3, 4]for i in range(len(a)): if a[i] == 2: breakelse: print(&#x27;yes&#x27;)print(&#x27;no&#x27;) 正常退出循环会执行else，使用break提前退出会跳过else iterable可迭代 简单说就是可以进行for循环的。字符串、list类型、字典类型、元组类型，包括自定义的类都是可以迭代。 序列 总览 1234graph LRx[序列]--&gt;a[序列类型] &amp; e[序列操作]a[序列类型]--&gt;b[列表 list] &amp; c[字符串 str] &amp; d[元组]e[序列操作]--&gt;f[索引] &amp; g[切片] &amp; h[加 乘] &amp; i[计算序列长] &amp; j[求序列极值] &amp; m[检查元素是否包含在序列中] &amp; k[其他序列内置函数] 序列的切片操作（以list为例） 可以使用索引访问列表内容。序列中的索引编号，都是从0开始递增 123numbers=[1,2,3,4,5,6]numbers[0] #输出1numbers[-1] #输出6 使用切片进行访问 123456789numbers=[1,2,3,4,5,6,7,8,9,10]numbers[:] #[1,2,3,4,5,6,7,8,9,10]取整个列表numbers[1:4] #[2,3,4]numbers[0:1] #[1]numbers[7:10] #[8,9,10]numbers[7:] #[8,9,10]numbers[:3] #[1,2,3]numbers[-3:] #[8,9,10]numbers[-3:-1] #[8,9] 没有倒数第0，表示从倒数第三个到倒数第一个 切片提供了两个索引来指定切片大的边界，第一个索引指定开始位置（包含在切片内），第二个索引指定的结束的位置，不包含在切片内。如果索引是负数，是从切片末尾进行，负数的索引不能获取列表中最后一个元素。比如numbers[-2:-1]这是倒数第二个元素，numbers[-1:0]这是一个空列表。 使用切片，指定步长，默认是1 [start：end：step] 1234numbers=[1,2,3,4,5,6,7,8,9,10]numbers[::1] #[1,2,3,4,5,6,7,8,9,10]numbers[2::2] #[3,5,7,9]numbers[2::-1] #[3,2,1] 第三个参数用于指定步长，如果是负数，即从右向左提取元素。numbers[2:4:-1] 是[]，步长是负数，从索引2的位置开始，向左到索引位置为4的位置，显然不存在，结果为[]。numbers[4:2:-1]，从索引位置4开始，向左到索引位置为2的地方，第一个索引包含在列表中，结果[5,4]。 可以使用切片方式，实现序列反转,字符串反转。 12str=&quot;nihao&quot;str[::-1] #&#x27;oahin&#x27; 序列加乘 1234str=&quot;c.biancheng.net&quot;print(&quot;C语言&quot;+&quot;中文网:&quot;+str) #C语言中文网：c.biancheng.netstr=&quot;C语言中文网&quot;print(str*3) #C语言中文网C语言中文网C语言中文网 检查元素是否包含在序列中 123str=&quot;c.biancheng.net&quot;print(&#x27;c&#x27;in str) #Trueprint(&#x27;c&#x27; not in str) #False 内置函数 函数 功能 len() 计算序列的长度，即返回序列中包含多少个元素。 max() 找出序列中的最大元素。注意，对序列使用 sum() 函数时，做加和操作的必须都是数字，不能是字符或字符串，否则该函数将抛出异常，因为解释器无法判定是要做连接操作（+ 运算符可以连接两个序列），还是做加和操作。 min() 找出序列中的最小元素。 list() 将序列转换为列表。 str() 将序列转换为字符串。 sum() 计算元素和。 sorted() 对元素进行排序。 reversed() 反向序列中的元素。 enumerate() 将序列组合为一个索引序列，多用在 for 循环中。 字符串 python转义字符（不熟悉的） 转义字符 描述 \\(在行尾时) 续行符 \\oyy 八进制数，y 代表 0~7 的字符，例如：\\012 代表换行。 \\xyy 十六进制数，以 \\x 开头，yy代表的字符，例如：\\x0a代表换行 字符串运算符 下表实例变量 a 值为字符串 “Hello”，b 变量值为 “Python”： 操作符 描述 实例 + 字符串连接 &gt;&gt;&gt;a + b ‘HelloPython’ * 重复输出字符串 &gt;&gt;&gt;a * 2 ‘HelloHello’ [] 通过索引获取字符串中字符 &gt;&gt;&gt;a[1] ‘e’ [ : ] 截取字符串中的一部分 &gt;&gt;&gt;a[1:4] ‘ell’ in 成员运算符 - 如果字符串中包含给定的字符返回 True &gt;&gt;&gt;”H” in a True not in 成员运算符 - 如果字符串中不包含给定的字符返回 True &gt;&gt;&gt;”M” not in a True r/R 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母”r”（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 &gt;&gt;&gt;print r’\\n’ \\n &gt;&gt;&gt; print R’\\n’ \\n % 格式字符串 请看下一章节 python 字符串格式化符号: 符 号 描述 %c 格式化字符及其ASCII码 %s 格式化字符串 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同%e，用科学计数法格式化浮点数 %g %f和%e的简写 %G %F 和 %E 的简写 %p 用十六进制数格式化变量的地址 格式化操作符辅助指令: 符号 功能 * 定义宽度或者小数点精度 - 用做左对齐 + 在正数前面显示加号( + ) 在正数前面显示空格 # 在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’) 0 显示的数字前面填充’0’而不是默认的空格 % ‘%%’输出一个单一的’%’ (var) 映射变量(字典参数) m.n. m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话) Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。 Python 输出字符串左对齐、右对齐、居中对齐 通过ljust(),center(),rjust()函数实现 通过format()函数格式化实现 python三引号 python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。 12345678#!/usr/bin/python3 para_str = &quot;&quot;&quot;这是一个多行字符串的实例多行字符串可以使用制表符TAB ( \\t )。也可以使用换行符 [ \\n ]。&quot;&quot;&quot;print (para_str) 12345这是一个多行字符串的实例多行字符串可以使用制表符TAB ( )。也可以使用换行符 [ ]。 f-string f-string 是 python3.6 之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。 f-string 格式化字符串以 f 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去，实例如下： 12345678910&gt;&gt;&gt; name = &#x27;Runoob&#x27;&gt;&gt;&gt; &#x27;Hello %s&#x27; % name&#x27;Hello Runoob&#x27;&gt;&gt;&gt; f&#x27;Hello &#123;name&#125;&#x27; # 替换变量&#x27;Hello Runoob&#x27;&gt;&gt;&gt; f&#x27;&#123;1+2&#125;&#x27; # 使用表达式&#x27;3&#x27;&gt;&gt;&gt; w = &#123;&#x27;name&#x27;: &#x27;Runoob&#x27;, &#x27;url&#x27;: &#x27;www.runoob.com&#x27;&#125;&gt;&gt;&gt; f&#x27;&#123;w[&quot;name&quot;]&#125;: &#123;w[&quot;url&quot;]&#125;&#x27;&#x27;Runoob: www.runoob.com&#x27; 在 Python 3.8 的版本中可以使用 = 符号来拼接运算表达式与结果： 123&gt;&gt;&gt; x = 1&gt;&gt;&gt; print(f&#x27;&#123;x+1=&#125;&#x27;) # Python 3.8&#x27;x+1=2&#x27; Unicode 字符串 在Python2中，普通字符串是以8位ASCII码进行存储的，而Unicode字符串则存储为16位unicode字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀 u。 在Python3中，所有的字符串都是Unicode字符串。 其他内建函数 字符串赋值 123456789101112a = &#x27; hello world! &#x27;print(a.strip())print(a.lstrip())print(a.rstrip())c = 1d = c #c和d实际是对同一个地址的引用, 如果b再被赋值其他值，那么就会为d分配不同的地址print(&#x27;c的内存地址%d&#x27;% id(c))print(&#x27;d的内存地址%d&#x27;% id(d))d = 2print(&#x27;c的内存地址%d&#x27;% id(c))print(&#x27;d的内存地址%d&#x27;% id(d))print(f&#x27;&#123;c=&#125;&#x27;) 12345678hello world!hello world! hello world!c的内存地址140724417992352d的内存地址140724417992352c的内存地址140724417992352d的内存地址140724417992384c=1 转义字符串与不转义的字符串相互转化 如下，通过print()打印出来的不再为转义字符串 12345678910&gt;&gt;&gt; import matplotlib&gt;&gt;&gt; matplotlib.__file__&#x27;D:\\\\Program Files\\\\python38\\\\lib\\\\site-packages\\\\matplotlib\\\\__init__.py&#x27;&gt;&gt;&gt; print(matplotlib.__file__)D:\\Program Files\\python38\\lib\\site-packages\\matplotlib\\__init__.py&gt;&gt;&gt; print(r&#x27;\\n\\n\\n&#x27;) #不转义字符串变为转义字符串\\n\\n\\n&gt;&gt;&gt; r&#x27;\\n\\n\\n&#x27;&#x27;\\\\n\\\\n\\\\n&#x27; u’string’、r’string’、f-string 1）字符串前加 u = unicode编码，后面字符串以 Unicode 格式 进行编码，一般用在中文字符串前面，防止因为源码储存格式问题，导致再次使用时出现乱码。 2）字符串前加 r = raw 原始输入，声明后面的字符串是普通字符串。 3）f-string，亦称为格式化字符串常量（formatted string literals）。f-string在形式上是以 f 或 F 修饰符引领的字符串（f&#39;xxx&#39; 或 F&#39;xxx&#39;），以大括号 &#123;&#125; 标明被替换的字段；f-string在本质上并不是字符串常量，而是一个在运行时运算求值的表达式。与其功能相同的还有%-formatting语句和str.format()函数 list 列表 [] 列表中数据可以是任意类型，类型可以混合 range() 与list的区别 range()是依次取顺序的数值，一般是用来进行循环迭代用的 list是一个列表，里面可以存各种类型 range可以强转为list类型 1234&gt;&gt;&gt; print(type(range(10)))&lt;class &#x27;range&#x27;&gt;&gt;&gt;&gt; print(type(list()))&lt;class &#x27;list&#x27;&gt; range(10)相当与range(0,10) range(0,10,2) 最后一个参数是步长 tuple 元组 () 是一种不可变序列，创建后不能做任何修改，只能查询，或者重新给元组赋值 1234tupleA = ()print(id(tupleA))tupleA = (&#x27;dsaf&#x27;,4 ,124.3, (1,3,6,&#x27;dzh&#x27;))print(id(tupleA)) 1223238636995202323864166464 可以看到重新赋值后，地址变了，因为元组一旦创建后不能改变，类似c语言常量字符串。 123tupleA = (&#x27;dsaf&#x27;,4 ,124.3, [1,3,6,&#x27;dzh&#x27;])tupleA[3][1] = 666;print(&#x27;tupleA中嵌套的列表是可以修改的：&#x27;, tupleA) 1tupleA中嵌套的列表是可以修改的： (&#x27;dsaf&#x27;, 4, 124.3, [1, 666, 6, &#x27;dzh&#x27;]) 元组中嵌套的列表是可以修改的 数据项可以是任何的数据类型 只有一个数据时，需要写一个逗号，不然会认为是整型 123456tupleB = (&#x27;peter&#x27;,)print(&#x27;元组只包含一个元素，最后需要一个逗号，否则不能识别为元组:&#x27;,tupleB)tupleB = (&#x27;peter&#x27;)print(tupleB)print(type((&#x27;peter&#x27;,)))print(type((&#x27;peter&#x27;))) 1234元组只包含一个元素，最后需要一个逗号，否则不能识别为元组: (&#x27;peter&#x27;,)peter&lt;class &#x27;tuple&#x27;&gt;&lt;class &#x27;str&#x27;&gt; range也可以强转为元组和集合 字典 不属于序列，没有下标概念，无序键值对集合 {}来表示字典对象，每个键值对通过逗号分开。 通过key访问，key不能重复 key不能修改，必须是不可变的类型（元组，字符串等），值可以是任意类型 函数参数、返回值、嵌套调用 调用函数前必须先定义 参数 传参、调用、不定长参数、缺省参数 参数类型： 必选参数、默认参数[缺省参数]、可选参数、关键字参数 缺省参数必须要在参数列表的尾部 可变参数传递进函数后是一个不能修改的元组 可变关键字参数传递进函数后是一个字典 函数定义中可变参数必须放在可变关键字参数之前 函数的备注信息 使用三引号放在函数内部开始 在pycharm中ctrl键+鼠标停留在函数上，就会显示出函数的备注信息 12345678def printInfo(): &#x27;&#x27;&#x27; 这里写函数的备注信息 :return: &#x27;&#x27;&#x27; print(&#x27;dzh的身高是%.2f&#x27; % 1.73) print(&#x27;dzh的体重是%.f&#x27; % 160) pass 下面是备注显示的信息，可以看到备注信息，函数的返回值是None 12def printInfo() -&gt; None这里写函数的备注信息 关键字参数 使用** 来定义 在函数体内参数关键字是一个字典类型，key必须是字符串 关键字参数可以直接指定实参传递给那个参数，那么就不需要关注变量的顺序。可以传递不定数量的键值对 参考：http://c.biancheng.net/view/2250.html 123456789def complexFunc(*args, **kwargs): print(args) print(kwargs) passcomplexFunc()complexFunc(1,2,3,4)# name =&#x27;dzh&#x27;,age=27 传递进入函数后是以字典的形式体现complexFunc(1,2,3,4,name =&#x27;dzh&#x27;,age=27) 123456()&#123;&#125;(1, 2, 3, 4)&#123;&#125;(1, 2, 3, 4)&#123;&#x27;name&#x27;: &#x27;dzh&#x27;, &#x27;age&#x27;: 27&#125; 函数分类 有参数无返回值 有参数有返回值 无参数无返回值 无参数有返回值 函数内部修改全局变量 要使用global关键字进行声明 1234567globalVar = &#x27;我是全局变量&#x27;print(&#x27;全局变量修改前：&#x27;, globalVar)def updataGlobalVar(): global globalVar globalVar = &#x27;更新了全局变量&#x27;updataGlobalVar()print(&#x27;全局变量修改后：&#x27;, globalVar) 12全局变量修改前： 我是全局变量全局变量修改后： 更新了全局变量 python中的传参是引用传参不是值传参 参考 Python中的引用传参 多种传参方式的对比：值传参，值的引用传参，指针传参（两类），指针的引用传参（两类） 匿名函数 lambda 语法： ​ lambda 参数1，参数2… ：表达式 特点： ​ 使用lambda关键字创建；没有名字；匿名函数冒号后的表达式有且只有一个，是表达式不是语句；自带return，且返回的结果就是表表达式的值。 缺点： ​ lambda缺点：只能是单个表达式，不是一个代码块，设计的目的是为了满足简单函数的场景，仅能封装有限逻辑，复杂逻辑要用def处理 三元运算代替if else双分支操作 b if a else c lambda表达式结合三元表达式应用 12345age = 25print(&#x27;可以参军&#x27; if age &gt; 18 else &#x27;继续上学&#x27;)funcTest = lambda age :&#x27;可以参军&#x27; if age &gt; 18 else &#x27;继续上学&#x27;print(funcTest(15)) 12可以参军继续上学 序列的内建函数 sort与sorted的区别 sort()方法是list的内置函数，只能用于列表，sort直接修改原始列表的内容； sorted()方法用于可迭代的序列，会返回一个排好序的新的序列。 函数语法中参数用中括号（[]）和逗号（,）嵌套表示是何种含义？ [, a[, b]]：嵌套形式表示 b 是独立于 a 的可选参数，即在传入 a 的情况下，b 可以自由地选择传入或省略。 [, a, b] ：扁平形式表示 a 与 b 合在一起是一组可选参数，即 a 和 b 必须同时传入或者同时省略，但不能只传入一个 python内置函数分类 数学运算 类型转换 序列操作 集合操作 python模块安装pip源配置windows配置在用户目录下有个pip.ini文件（没有就创建），参考如下配置： 123456[global]index-url = https://mirrors.aliyun.com/pypi/simple[install]trusted-host=mirrors.aliyun.com/pypi[list]format=columns 默认配置的是国外的Python官方库，因为国内连接国外的网络比较慢，因此一般都要先将它配置为国内的地址 [global]表示所有的模块都使用这个地址来下载 [install]表示使用信任这个地址 [list]表示模块输出信息的格式 Linux配置命令行安装python某块安装命令pip install module_name 注意要在window的命令行下安装，而不是在python的命令行 实际会安装到lib目录，如：D:\\Program Files\\python38\\Lib\\site-packages 查看本地python类库详细信息 配置了python的环境变量 在命令行输入： python -m pydoc -p 1234 python -m pydoc 表示打开pydoc模块，该模块用于查python文档 -p 1234 表示在端口号1234上打开server，端口号可自行设置 浏览器打开： 127.0.0.1：1234就可以看到文档目录 也可以在python命令行通过如下方式找到模块的安装位置 123&gt;&gt;&gt; import matplotlib&gt;&gt;&gt; matplotlib.__file__&#x27;D:\\\\Program Files\\\\python38\\\\lib\\\\site-packages\\\\matplotlib\\\\__init__.py&#x27; python数据画图相关模块 Pyecharts Matplotlib 官网 PyechartsMatplotlib例112345import matplotlib.pyplot as plta = [51,226,208,165,202,286,190,212,219,271,36]plt.plot(a,a*1.5,a,a*2.5,a,a*3.5,a,a*4.5)plt.show() 例2面向对象背景介绍概念面向对象编程：oop[object oriended programming]，关注设计思维 面向过程编程：按照解决问题的步骤去写代码，根据业务逻辑去写代码 两种编程模式对比面向对象更适合大型项目 面向过程关注怎么做？面向对象关注谁来做？ 面向过程 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。缺点：没有面向对象易维护、易复用、易扩展 面向对象 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护缺点：性能比面向过程低 类和对象类是从实际场景中理想抽象的模板，现实世界行为抽到到方法，特征抽象为属性 对象就是通过模板产生的一个实例 类概念类名、属性、行为 创建类的时候实际上，没有在内存中创建任何空间，当实例化一个对象的时候，会在内存中创建一个对象空间 实例方法在类的内部，使用def关键字可以定义一个实例方法，与一般函数定义不同，类的方法必须包含参数self，且为第一个参数 类属性定义在类中的变量 实例属性类似实例方法，在方法内部定义的，并且通过类似self.变量名 的形式定义的变量 魔术方法双下划线开始和结尾的方法，python中已经内置好的类的方法 方法名”__XXX__“ ____init____方法初始化的方法，定义实例属性和初始化实例属性 实例化对象的时候自动调用，完成 一些初始化设置 利用传参机制可以方便的实例化一个对象，不用专，门为一个实例手动添加属性 selfself和对象指向同一个内存地址，可以认为self是对象的引用，可以理解为对象自己，对谋个对象调用其方法时，python解释器会把这个对象作为第一个参数传递给函数，所以开发者只需要传递后面的参数即可 只有在类中定义实例方法的时候才有意义，在调用时不必手动传递（但是要用变量来接受），解释器会自动传递 名字不一定叫self，也可以叫其他，不过约定俗成是self，相当于java中的this 每个实例函数的第一个参数都是用来接受self对象自己，名字也可以不统一 ____new____与____init____区别__new__ 类的实例化方法，必须要返回该实例，否则对象创建失败 至少有一个参数是cls，代表要实例化的类，此参数在实例化的时由python解释器自动传递 函数执行new在前，init在后 __init__ 用来做数据属性的初始化工作，也可以认为是该实例的构造方法，接受类的实例self，并对其进行构造 多继承一个子类可以同时继承多个父类。 类的传递过程中，父类又叫基类，子类又叫派生类，父类的方法可以一级一级的传递给子类。多少级都可以传递。一般情况建议不超过三级 重写方法子类中有同名方法，子类的可以覆盖父类的，覆盖的顺序实际上与继承的顺序是对应的 父类的方法无法满足子类的需要，那么子类就可以重写父类的方法，或者晚上父类的方法 子类中调用父类方法可以使用父类名手动调用，也可以使用super() 方法自动的去找父类的方法，如果有多个父类，就逐个去找，知道找到为止；","categories":[],"tags":[]},{"title":"","slug":"git 命令总结","date":"2021-07-11T17:46:40.022Z","updated":"2021-07-11T17:46:40.026Z","comments":true,"path":"2021/07/12/git 命令总结/","link":"","permalink":"https://duan-zhenghong.github.io/dzh.github.io/2021/07/12/git%20%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/","excerpt":"","text":"git 命令总结 1、恢复文件如果不小心在本地删错了文件，但是版本库中还有，这时可以用 如下命令把误删的文件恢复到最新版本： 12$ git checkout -- file #恢复删除的某个文件$ git checkout -- * #恢复删除的所有文件 git checkout – file 其实是用版本库或者暂存区里的版本替换工作区的版本，无论工作区是修改还是删除都可以”一键还原“。","categories":[],"tags":[]},{"title":"test","slug":"test","date":"2021-07-11T17:16:30.000Z","updated":"2021-07-11T17:16:49.300Z","comments":true,"path":"2021/07/12/test/","link":"","permalink":"https://duan-zhenghong.github.io/dzh.github.io/2021/07/12/test/","excerpt":"","text":"clang-format 使用手册安装ubuntu安装clang-format1sudo apt-get install clang-format 手动安装clang-format 下载 文件clang+llvm-11.0.0-x86_64-linux-sles12.4.tar.xz 1wget https://github.com/llvm/llvm-project/releases/download/llvmorg-11.0.0/clang+llvm-11.0.0-x86_64-linux-sles12.4.tar.xz 解压文件 1tar -xf clang+llvm-11.0.0-x86_64-linux-sles12.4.tar.xz 解压目录如下 123456.├── bin├── include├── lib├── libexec└── share bin 文件中有 clang-format 的可执行文件 将clang-format放入 /usr/bin目录下完成安装 1mv .clang-format /usr/bin 查看版本如下，安装成功 12root@dzh-pc:/# clang-format-10 -versionclang-format version 10.0.0-4ubuntu1 vscode中使用clang-format部署 .clang-format文件在工程根目录下新建 .clang-format 文件，填入规则，如下是基于google的格式进行修改的一个例子，仅供参考 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#基础样式BasedOnStyle: Google#指针的*的挨着哪边PointerAlignment: Right#访问修饰符前的空格AccessModifierOffset: -4# 缩进宽度IndentWidth: 4# 连续的空行保留几行MaxEmptyLinesToKeep: 1# 圆括号的换行方式BreakBeforeBraces: Attach# 是否允许短方法单行AllowShortFunctionsOnASingleLine: true# 支持一行的ifAllowShortIfStatementsOnASingleLine: true# 在未封闭(括号的开始和结束不在同一行)的括号中的代码是否对齐AlignAfterOpenBracket: true# switch的case缩进IndentCaseLabels: true# 针对OC的block的缩进宽度ObjCBlockIndentWidth: 4# 针对OC，属性名后加空格ObjCSpaceAfterProperty: true# 每行字符的长度ColumnLimit: 120# 注释对齐AlignTrailingComments: true# 括号后加空格SpaceAfterCStyleCast: false# 换行的时候对齐操作符AlignOperands: true# 中括号两边空格 []SpacesInSquareBrackets: false# 多行声明语句按照=对齐AlignConsecutiveDeclarations: false# 容器类的空格 例如 OC的字典SpacesInContainerLiterals: false# 在构造函数初始化时按逗号断行，并以冒号对齐BreakConstructorInitializersBeforeComma: true# 函数参数换行AllowAllParametersOfDeclarationOnNextLine: true#在续行(# 下一行)时的缩进长度ContinuationIndentWidth: 4# tab键盘的宽度TabWidth: 4# 赋值运算符前加空格SpaceBeforeAssignmentOperators: true# 行尾的注释前加1个空格SpacesBeforeTrailingComments: 1 设置保存时自动格式化在vscode配置文件目录中添加文件settings.json，内容填写如下（该设置仅针对该工程）： 123&#123; &quot;editor.formatOnSave&quot;: true&#125; 或者在设置中搜索 format on save，勾选对应选项即可（该设置针对全局） 参考文献https://releases.llvm.org/download.html clang-format 插件使用说明 https://clang.llvm.org/docs/ClangFormatStyleOptions.html","categories":[],"tags":[]},{"title":"test_my_site","slug":"test-my-site","date":"2021-07-11T15:02:44.000Z","updated":"2021-07-11T15:02:44.066Z","comments":true,"path":"2021/07/11/test-my-site/","link":"","permalink":"https://duan-zhenghong.github.io/dzh.github.io/2021/07/11/test-my-site/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-07-11T13:41:03.489Z","updated":"2021-07-11T13:41:03.489Z","comments":true,"path":"2021/07/11/hello-world/","link":"","permalink":"https://duan-zhenghong.github.io/dzh.github.io/2021/07/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}